{"version":3,"sources":["webpack://programs/./node_modules/tinytime/dist/tinytime.js","webpack://programs/./src/templates/pagination.jsx"],"names":["SubToTypeIdentifierMap","months","days","paddWithZeros","int","compiler","tokens","date","options","month","getMonth","year","getFullYear","hours","getHours","seconds","getSeconds","minutes","getMinutes","day","getDate","compiled","index","length","token","t","v","slice","mnth","padMonth","getDay","padDays","hour","padHours","hour24","parser","template","position","text","char","push","sub","module","exports","arguments","undefined","templateAST","render","postDateTemplate","tinytime","PostLink","title","slug","className","to","dateTime","Date","PaginationTemplate","props","pageContext","currentPage","isFirst","isLast","numPages","prevPage","nextPage","links","data","allMdx","posts","map","x","node","frontmatter","fields","name","content","rel"],"mappings":"qGAQA,IAcIA,EAAyB,CAC3B,KAdc,IAed,GAdiB,IAejB,GALgB,IAMhB,KAfa,IAgBb,GAfgB,IAgBhB,KAfiB,IAgBjB,GAVkB,IAWlB,GAZQ,IAaR,EAjBS,IAkBT,EAXW,IAYX,GAlBY,IAmBZ,GAlBY,IAmBZ,EAlBuB,KA0BrBC,EAAS,CAAC,UAAW,UAAW,QAAS,QAAS,MAAO,OAAQ,OAAQ,SAAU,YAAa,UAAW,WAAY,YACvHC,EAAO,CAAC,SAAU,SAAU,UAAW,YAAa,WAAY,SAAU,YAM9E,SAASC,EAAcC,GACrB,OAAOA,EAAM,GAAK,IAAMA,EAAM,GAAKA,EAqBrC,SAASC,EAASC,EAAQC,EAAMC,GAU9B,IATA,IAfcJ,EAeVK,EAAQF,EAAKG,WACbC,EAAOJ,EAAKK,cACZC,EAAQN,EAAKO,WACbC,EAAUR,EAAKS,aACfC,EAAUV,EAAKW,aACfC,EAAMZ,EAAKa,UACXC,EAAW,GACXC,EAAQ,EAELA,EAAQhB,EAAOiB,QAAQ,CAC5B,IAAIC,EAAQlB,EAAOgB,GAEnB,OAAQE,EAAMC,GACZ,IA9ES,IAgFPJ,GAAYG,EAAME,EAClB,MAEF,IAzEI,IA0EFL,IAlCQjB,EAkCWe,GAjCZ,IAAM,GAAY,IAAPf,EAAYA,EAAM,KAAOA,EAAM,IAAM,GAAY,IAAPA,EAAYA,EAAM,KAAOA,EAAM,IAAM,GAAY,IAAPA,EAAYA,EAAM,KAAOA,EAAM,KAkCrI,MAEF,IArFa,IAsFXiB,GAAYpB,EAAOQ,GAAOkB,MAAM,EAAG,GACnC,MAEF,IA1FU,IA2FRN,GAAYpB,EAAOQ,GACnB,MAEF,IAnFY,IAoFV,IAAImB,EAAOnB,EAAQ,EAEfD,EAAQqB,WACVD,EAAOzB,EAAcyB,IAGvBP,GAAYO,EACZ,MAEF,IAtGS,IAuGPP,GAAYV,EACZ,MAEF,IAzGY,IA0GVU,IAAaV,EAAO,IAAIgB,MAAM,GAC9B,MAEF,IA5Ga,IA6GXN,GAAYnB,EAAKK,EAAKuB,UACtB,MAEF,IA1Gc,IA2GZT,GAAYb,EAAQuB,QAAU5B,EAAcgB,GAAOA,EACnD,MAEF,IAnHK,IAoHH,IAAIa,EAAiB,IAAVnB,GAAyB,KAAVA,EAAe,GAAKA,EAAQ,GAElDL,EAAQyB,WACVD,EAAO7B,EAAc6B,IAGvBX,GAAYW,EACZ,MAEF,IAtHO,IAuHL,IAAIE,EAASrB,EAETL,EAAQyB,WACVC,EAAS/B,EAAc+B,IAGzBb,GAAYa,EACZ,MAEF,IAtIQ,IAuINb,GAAYlB,EAAcc,GAC1B,MAEF,IAzIQ,IA0INI,GAAYlB,EAAcY,GAC1B,MAEF,IA5ImB,IA6IjBM,GAAYR,GAAS,GAAK,KAAO,KAIrCS,IAGF,OAAOD,EAyBT,SAASc,EAAOC,GA4Bd,IA3BA,IAAI9B,EAAS,GAOT+B,EAAW,EAkBXC,EAAO,GAEJD,EAAWD,EAASb,QAAQ,CACjC,IAAIgB,EAAOH,EAASC,KAMpB,GAAa,MAATE,EAAc,CAEZD,GACFhC,EAAOkC,KAAK,CACVf,EA7NK,IA8NLC,EAAGY,IAIPA,EAAO,GACP,IAAIG,EAAM,GAGV,IAFAF,EAAOH,EAASC,KAEA,MAATE,GACLE,GAAOF,EACPA,EAAOH,EAASC,KAGlB/B,EAAOkC,KAAK,CACVf,EAAGzB,EAAuByC,UAI1BH,GAAQC,EAgBd,OAPID,GACFhC,EAAOkC,KAAK,CACVf,EA3PS,IA4PTC,EAAGY,IAIAhC,EAcToC,EAAOC,QAVP,SAAkBP,GAChB,IAAI5B,EAAUoC,UAAUrB,OAAS,QAAsBsB,IAAjBD,UAAU,GAAmBA,UAAU,GAAK,GAC9EE,EAAcX,EAAOC,GACzB,MAAO,CACLW,OAAQ,SAAgBxC,GACtB,OAAOF,EAASyC,EAAavC,EAAMC,O,uuBCzQzC,IAAMwC,EAAmBC,IAAS,+BAE5BC,EAAW,SAAC,GAA2B,IAAzBC,EAAwB,EAAxBA,MAAO5C,EAAiB,EAAjBA,KAAM6C,EAAW,EAAXA,KAC/B,OACE,uBAAKC,UAAU,QACb,gBAAC,KAAD,CACEC,GAAIF,EACJC,UAAU,0DAETF,GAEH,sBAAIE,UAAU,cACZ,2BACE,sBAAIA,UAAU,WAAd,gBACA,sBAAIA,UAAU,iDACZ,wBAAME,SAAUhD,GACbyC,EAAiBD,OAAO,IAAIS,KAAKjD,UASjC,SAASkD,EAAmBC,GACzC,MAAkCA,EAAMC,YAAhCC,EAAR,EAAQA,YAEFC,EAA0B,IAAhBD,EACVE,EAASF,IAHf,EAAqBG,SAKfC,EAAQ,aAAeJ,EAAc,GACrCK,EAAQ,aAAeL,EAAc,GAA7B,IAGRM,EADYR,EAAMS,KAAKC,OAArBC,MACYC,KAAI,SAACC,GAAD,cAAaA,EAAEC,KAAKC,aAAgBF,EAAEC,KAAKE,WAEnE,OACE,wBAAMrB,UAAU,0BACd,gBAAC,IAAD,KACE,6DACA,wBACEsB,KAAK,cACLC,QAAQ,kEAGZ,gBAAC,IAAD,KACE,uBAAKvB,UAAU,QACb,gBAAC,IAAD,oBAGJ,gBAAC,IAAD,KACGa,EAAMI,KAAI,SAACC,GAAD,OACT,gBAACrB,EAAaqB,OAGlB,gBAAC,IAAD,MACIV,GACA,gBAAC,KAAD,CACEP,GAAIU,EACJa,IAAI,OACJxB,UAAU,8DAHZ,eAQAS,GACA,gBAAC,KAAD,CACER,GAAIW,EACJY,IAAI,OACJxB,UAAU,8DAHZ","file":"component---src-templates-pagination-jsx-38a6a39ddede72ce1f14.js","sourcesContent":["'use strict'; //      \n\n/**\n * We want to represent each subs. type as minimally as possible,\n * so instead of using strings we just use characters, which lets us\n * represent 27 individual subs. using a single character each.\n */\n\nvar UserText = 'a';\nvar FullMonth = 'b';\nvar PartialMonth = 'c';\nvar FullYear = 'd';\nvar PartialYear = 'e';\nvar DayOfTheWeek = 'f';\nvar Hour = 'g';\nvar Minutes = 'h';\nvar Seconds = 'i';\nvar PostOrAnteMeridiem = 'j';\nvar Day = 'k';\nvar DayOfTheMonth = 'l';\nvar NumberMonth = 'n';\nvar Hour24 = 'm';\nvar SubToTypeIdentifierMap = {\n  'MMMM': FullMonth,\n  'MM': PartialMonth,\n  'Mo': NumberMonth,\n  'YYYY': FullYear,\n  'YY': PartialYear,\n  'dddd': DayOfTheWeek,\n  'DD': DayOfTheMonth,\n  'Do': Day,\n  'h': Hour,\n  'H': Hour24,\n  'mm': Minutes,\n  'ss': Seconds,\n  'a': PostOrAnteMeridiem\n}; //      \n\n/**\n * These types help ensure we don't misspell them anywhere. They will be\n * removed during build.\n */\n\nvar months = [\"January\", \"Febuary\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"];\nvar days = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"];\n/**\n * Takes an integer and returns a string left padded with\n * a zero to the left. Used to display minutes and hours (1:01:00PM);\n */\n\nfunction paddWithZeros(int) {\n  return int < 10 ? '0' + int : '' + int;\n}\n/**\n * Adds suffix to day, so 16 becomes 16th.\n */\n\n\nfunction suffix(int) {\n  return int % 10 == 1 && int != 11 ? int + \"st\" : int % 10 == 2 && int != 12 ? int + \"nd\" : int % 10 == 3 && int != 13 ? int + \"rd\" : int + \"th\";\n}\n/**\n * The compiler takes in our array of tokens returned from the parser\n * and returns the formed template. It just iterates over the tokens and\n * appends some text to the returned string depending on the type of token.\n * @param {Array<Tokens>} tokens\n * @param {Date} date\n * @param {TinyTimeOptions} options\n * @returns {String}\n */\n\n\nfunction compiler(tokens, date, options) {\n  var month = date.getMonth();\n  var year = date.getFullYear();\n  var hours = date.getHours();\n  var seconds = date.getSeconds();\n  var minutes = date.getMinutes();\n  var day = date.getDate();\n  var compiled = '';\n  var index = 0;\n\n  while (index < tokens.length) {\n    var token = tokens[index];\n\n    switch (token.t) {\n      case UserText:\n        // $FlowFixMe flow doesn't know that v is always populated on UserText\n        compiled += token.v;\n        break;\n\n      case Day:\n        compiled += suffix(day);\n        break;\n\n      case PartialMonth:\n        compiled += months[month].slice(0, 3);\n        break;\n\n      case FullMonth:\n        compiled += months[month];\n        break;\n\n      case NumberMonth:\n        var mnth = month + 1;\n\n        if (options.padMonth) {\n          mnth = paddWithZeros(mnth);\n        }\n\n        compiled += mnth;\n        break;\n\n      case FullYear:\n        compiled += year;\n        break;\n\n      case PartialYear:\n        compiled += (year + '').slice(2);\n        break;\n\n      case DayOfTheWeek:\n        compiled += days[date.getDay()];\n        break;\n\n      case DayOfTheMonth:\n        compiled += options.padDays ? paddWithZeros(day) : day;\n        break;\n\n      case Hour:\n        var hour = hours === 0 || hours === 12 ? 12 : hours % 12;\n\n        if (options.padHours) {\n          hour = paddWithZeros(hour);\n        }\n\n        compiled += hour;\n        break;\n\n      case Hour24:\n        var hour24 = hours;\n\n        if (options.padHours) {\n          hour24 = paddWithZeros(hour24);\n        }\n\n        compiled += hour24;\n        break;\n\n      case Minutes:\n        compiled += paddWithZeros(minutes);\n        break;\n\n      case Seconds:\n        compiled += paddWithZeros(seconds);\n        break;\n\n      case PostOrAnteMeridiem:\n        compiled += hours >= 12 ? 'PM' : 'AM';\n        break;\n    }\n\n    index++;\n  }\n\n  return compiled;\n} //      \n\n/**\n * t is type and v is value. Minified property\n * names are being used because the current minification\n * step does not mangle property names, and we want to\n * reduce bundle size as much as possible.\n */\n\n/**\n * Rather than using a bunch of potentially confusing regular\n * expressions to match patterns in templates, we use a simple\n * parser, taking the aproach of a compiler. This is equivalent\n * to a lexer as it returns a stream of tokens. Since there is\n * no additional analysis required for semantics we just call\n * it a parser.\n * \n * It will return an array of tokens, each corresponding to either\n * UserText (just text we want to render) or any number of the\n * subsitution types stored in SubToTypeIdentifierMap.\n * \n */\n\n\nfunction parser(template) {\n  var tokens = [];\n  /**\n   * We iterate through each character in the template string, and track\n   * the index of the character we're processing with `position`. We start\n   * at 0, the first character.\n   */\n\n  var position = 0;\n  /**\n   * `text` is used to accumulate what we call \"UserText\", or simply text that\n   * is not a subsitution. For example, in the template:\n   *  \n   *  \"The day is {day}.\"\n   * \n   * There are two instances of `UserText`, \"The day is \" and \".\", which is the text\n   * befor eand after the subsitution. With this template our tokens would look something like:\n   * \n   * [\n   *  { type: UserText, value: \"The day is \"},\n   *  { type : DaySub },\n   *  { type: UserText, value: \".\" }\n   * ]\n   * \n   */\n\n  var text = '';\n\n  while (position < template.length) {\n    var char = template[position++];\n    /**\n     * A bracket indicates we're starting a subsitution. Any characters after this,\n     * and before the next '}' will be considered part of the subsitution name.\n     */\n\n    if (char === '{') {\n      // Push any `UserText` we've accumulated and reset the `text` variable.\n      if (text) {\n        tokens.push({\n          t: UserText,\n          v: text\n        });\n      }\n\n      text = '';\n      var sub = '';\n      char = template[position++];\n\n      while (char !== '}') {\n        sub += char;\n        char = template[position++];\n      }\n\n      tokens.push({\n        t: SubToTypeIdentifierMap[sub]\n      });\n    } // Anything not inside brackets is just plain text.\n    else {\n        text += char;\n      }\n  }\n  /**\n   * We might have some text after we're done iterating through the template if\n   * the template ends with some `UserText`.\n   */\n\n\n  if (text) {\n    tokens.push({\n      t: UserText,\n      v: text\n    });\n  }\n\n  return tokens;\n} //      \n\n\nfunction tinytime(template) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var templateAST = parser(template);\n  return {\n    render: function render(date) {\n      return compiler(templateAST, date, options);\n    }\n  };\n}\n\nmodule.exports = tinytime;","import React from \"react\";\nimport tinytime from \"tinytime\";\nimport { Helmet } from \"react-helmet\";\nimport { graphql, Link } from \"gatsby\";\n\nimport SectionContainer from \"../components/SectionContainer\";\nimport PageTitle from \"../components/PageTitle\";\n\nconst postDateTemplate = tinytime(\"{dddd}, {MMMM} {DD}, {YYYY}\");\n\nconst PostLink = ({ title, date, slug }) => {\n  return (\n    <div className=\"my-8\">\n      <Link\n        to={slug}\n        className=\"text-green-600 hover:text-green-700 text-2xl font-bold\"\n      >\n        {title}\n      </Link>\n      <dl className=\"space-y-10\">\n        <div>\n          <dt className=\"sr-only\">Published on</dt>\n          <dd className=\"text-base leading-6 font-medium text-gray-500\">\n            <time dateTime={date}>\n              {postDateTemplate.render(new Date(date))}\n            </time>\n          </dd>\n        </div>\n      </dl>\n    </div>\n  );\n};\n\nexport default function PaginationTemplate(props) {\n  const { currentPage, numPages } = props.pageContext;\n\n  const isFirst = currentPage === 1;\n  const isLast = currentPage === numPages;\n\n  const prevPage = `/explore/${currentPage - 1}`;\n  const nextPage = `/explore/${currentPage + 1}/`;\n\n  const { posts } = props.data.allMdx;\n  const links = posts.map((x) => ({ ...x.node.frontmatter, ...x.node.fields }));\n\n  return (\n    <main className=\"pt-6 xl:pb-10 divide-y\">\n      <Helmet>\n        <title>Explore Programs - Varun Dev</title>\n        <meta\n          name=\"description\"\n          content=\"Pagtinated list of programs in various programming languages\"\n        />\n      </Helmet>\n      <SectionContainer>\n        <div className=\"py-8\">\n          <PageTitle>All Posts</PageTitle>\n        </div>\n      </SectionContainer>\n      <SectionContainer>\n        {links.map((x) => (\n          <PostLink {...x} />\n        ))}\n      </SectionContainer>\n      <SectionContainer>\n        {!isFirst && (\n          <Link\n            to={prevPage}\n            rel=\"next\"\n            className=\"inline-block text-green-600 hover:text-green-700 pt-8 pr-8\"\n          >\n            &larr; Previous\n          </Link>\n        )}\n        {!isLast && (\n          <Link\n            to={nextPage}\n            rel=\"next\"\n            className=\"inline-block text-green-600 hover:text-green-700 pt-8 pr-8\"\n          >\n            Next &rarr;\n          </Link>\n        )}\n      </SectionContainer>\n    </main>\n  );\n}\n\nexport const query = graphql`\n  query ($skip: Int!, $limit: Int!) {\n    allMdx(\n      sort: { fields: [frontmatter___date], order: DESC }\n      filter: {\n        fileAbsolutePath: { regex: \"//src/posts//\" }\n        frontmatter: { published: { ne: false } }\n      }\n      limit: $limit\n      skip: $skip\n    ) {\n      posts: edges {\n        node {\n          frontmatter {\n            date\n            title\n            description\n          }\n          fields {\n            slug\n          }\n        }\n      }\n    }\n  }\n`;\n"],"sourceRoot":""}